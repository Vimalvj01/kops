? Resources.AWSEC2LaunchTemplatemasterustest1amastersthisistrulyareallyreallylongclusternameminimalexamplecom.Properties.LaunchTemplateData.UserData
: "#!/bin/bash\nset -o errexit\nset -o nounset\nset -o pipefail\n\nNODEUP_URL_AMD64=https://artifacts.k8s.io/binaries/kops/1.21.0-alpha.1/linux/amd64/nodeup,https://github.com/kubernetes/kops/releases/download/v1.21.0-alpha.1/nodeup-linux-amd64\nNODEUP_HASH_AMD64=585fbda0f0a43184656b4bfc0cc5f0c0b85612faf43b8816acca1f99d422c924\nNODEUP_URL_ARM64=https://artifacts.k8s.io/binaries/kops/1.21.0-alpha.1/linux/arm64/nodeup,https://github.com/kubernetes/kops/releases/download/v1.21.0-alpha.1/nodeup-linux-arm64\nNODEUP_HASH_ARM64=7603675379699105a9b9915ff97718ea99b1bbb01a4c184e2f827c8a96e8e865\n\nexport
  AWS_REGION=us-test-1\n\n\n\n\nsysctl -w net.core.rmem_max=16777216 || true\nsysctl
  -w net.core.wmem_max=16777216 || true\nsysctl -w net.ipv4.tcp_rmem='4096 87380 16777216'
  || true\nsysctl -w net.ipv4.tcp_wmem='4096 87380 16777216' || true\n\n\nfunction
  ensure-install-dir() {\n  INSTALL_DIR=\"/opt/kops\"\n  # On ContainerOS, we install
  under /var/lib/toolbox; /opt is ro and noexec\n  if [[ -d /var/lib/toolbox ]]; then\n
  \   INSTALL_DIR=\"/var/lib/toolbox/kops\"\n  fi\n  mkdir -p ${INSTALL_DIR}/bin\n
  \ mkdir -p ${INSTALL_DIR}/conf\n  cd ${INSTALL_DIR}\n}\n\ntry-download-file() {\n
  \ local -r url=\"$1\"\n  local -r file=\"$2\"\n  local -r auth=\"$3\"\n  if [[ \"$auth\"
  == \"\" ]]; then\n        if curl -f --compressed -Lo \"${file}\" --connect-timeout
  20 --retry 6 --retry-delay 10 \"${url}\"; then return 0; fi\n        if wget --compression=auto
  -O \"${file}\" --connect-timeout=20 --tries=6 --wait=10 \"${url}\"; then return
  0; fi\n        if curl -f -Lo \"${file}\" --connect-timeout 20 --retry 6 --retry-delay
  10 \"${url}\"; then return 0; fi\n        if wget -O \"${file}\" --connect-timeout=20
  --tries=6 --wait=10 \"${url}\"; then return 0; fi\n  else\n        if curl -f --compressed
  -Lo \"${file}\" -v -H \"Authorization: Bearer ${auth}\" --connect-timeout 20 --retry
  6 --retry-delay 10 \"${url}\"; then return 0; fi\n        if curl -f -Lo \"${file}\"
  -v -H \"Authorization: Bearer ${auth}\" --connect-timeout 20 --retry 6 --retry-delay
  10 \"${url}\"; then return 0; fi\n  fi\n  return 1\n}\n\n# Retry a download until
  we get it. args: name, sha, urls\ndownload-or-bust() {\n  local -r file=\"$1\"\n
  \ local -r hash=\"$2\"\n  local -r urls=( $(split-commas \"$3\") )\n\n  if [[ -f
  \"${file}\" ]]; then\n    if ! validate-hash \"${file}\" \"${hash}\"; then\n      rm
  -f \"${file}\"\n    else\n      return 0\n    fi\n  fi\n\n  while true; do\n    for
  url in \"${urls[@]}\"; do\n      local access_token=\"\"\n      if [[ \"${GCE_ACCESS_TOKEN_URL:-}\"
  != \"\" ]]; then\n        # The token always begins with 'ya29' and continues until
  the next double-quote.\n        # We would normally use jq to be more tolerant of
  format changes, \n        # but it's not available in flatcar during startup (depends
  on docker, which isn't up yet.)\n        access_token=$(curl \"$GCE_ACCESS_TOKEN_URL\"
  -H \"Metadata-Flavor: Google\" | grep -Eo 'ya29\\.[^\\\"]*')\n      fi\n\n      echo
  \"Attempting download of ${url}\"\n      if ! try-download-file \"${url}\" \"${file}\"
  \"${access_token}\" ; then\n        continue\n      fi\n      if ! validate-hash
  \"${file}\" \"${hash}\"; then\n        echo \"== Hash validation of ${url} failed.
  Retrying. ==\"\n        rm -f \"${file}\"\n      else\n        echo \"== Downloaded
  ${url} (SHA256 = ${hash}) ==\"\n        return\n      fi\n    done\n\n    echo \"Download
  failed with all plausible commands; sleeping before retrying\"\n    sleep 60\n  done\n}\n\nvalidate-hash()
  {\n  local -r file=\"$1\"\n  local -r expected=\"$2\"\n  local actual\n\n  actual=$(sha256sum
  ${file} | awk '{ print $1 }') || true\n  if [[ \"${actual}\" != \"${expected}\"
  ]]; then\n    echo \"== ${file} corrupted, hash ${actual} doesn't match expected
  ${expected} ==\"\n    return 1\n  fi\n}\n\nfunction split-commas() {\n  echo $1
  | tr \",\" \"\\n\"\n}\n\nfunction download-release() {\n  case \"$(uname -m)\" in\n
  \ x86_64*|i?86_64*|amd64*)\n    NODEUP_URL=\"${NODEUP_URL_AMD64}\"\n    NODEUP_HASH=\"${NODEUP_HASH_AMD64}\"\n
  \   ;;\n  aarch64*|arm64*)\n    NODEUP_URL=\"${NODEUP_URL_ARM64}\"\n    NODEUP_HASH=\"${NODEUP_HASH_ARM64}\"\n
  \   ;;\n  *)\n    echo \"Unsupported host arch: $(uname -m)\" >&2\n    exit 1\n
  \   ;;\n  esac\n\n  cd ${INSTALL_DIR}/bin\n  download-or-bust nodeup \"${NODEUP_HASH}\"
  \"${NODEUP_URL}\"\n\n  chmod +x nodeup\n\n  echo \"Running nodeup\"\n  # We can't
  run in the foreground because of https://github.com/docker/docker/issues/23793\n
  \ ( cd ${INSTALL_DIR}/bin; ./nodeup --install-systemd-unit --conf=${INSTALL_DIR}/conf/kube_env.yaml
  --v=8  )\n}\n\n####################################################################################\n\n/bin/systemd-machine-id-setup
  || echo \"failed to set up ensure machine-id configured\"\n\necho \"== nodeup node
  config starting ==\"\nensure-install-dir\n\ncat > conf/cluster_spec.yaml << '__EOF_CLUSTER_SPEC'\ncloudConfig:\n
  \ awsEBSCSIDriver:\n    enabled: false\n  manageStorageClasses: true\ncontainerRuntime:
  containerd\ncontainerd:\n  logLevel: info\n  version: 1.4.12\ndocker:\n  skipInstall:
  true\nencryptionConfig: null\netcdClusters:\n  events:\n    version: 3.4.13\n  main:\n
  \   version: 3.4.13\nkubeAPIServer:\n  allowPrivileged: true\n  anonymousAuth: false\n
  \ apiAudiences:\n  - kubernetes.svc.default\n  apiServerCount: 1\n  authorizationMode:
  AlwaysAllow\n  bindAddress: 0.0.0.0\n  cloudProvider: aws\n  enableAdmissionPlugins:\n
  \ - NamespaceLifecycle\n  - LimitRanger\n  - ServiceAccount\n  - DefaultStorageClass\n
  \ - DefaultTolerationSeconds\n  - MutatingAdmissionWebhook\n  - ValidatingAdmissionWebhook\n
  \ - NodeRestriction\n  - ResourceQuota\n  etcdServers:\n  - https://127.0.0.1:4001\n
  \ etcdServersOverrides:\n  - /events#https://127.0.0.1:4002\n  image: registry.k8s.io/kube-apiserver:v1.21.0\n
  \ kubeletPreferredAddressTypes:\n  - InternalIP\n  - Hostname\n  - ExternalIP\n
  \ logLevel: 2\n  requestheaderAllowedNames:\n  - aggregator\n  requestheaderExtraHeaderPrefixes:\n
  \ - X-Remote-Extra-\n  requestheaderGroupHeaders:\n  - X-Remote-Group\n  requestheaderUsernameHeaders:\n
  \ - X-Remote-User\n  securePort: 443\n  serviceAccountIssuer: https://api.internal.this.is.truly.a.really.really.long.cluster-name.minimal.example.com\n
  \ serviceAccountJWKSURI: https://api.internal.this.is.truly.a.really.really.long.cluster-name.minimal.example.com/openid/v1/jwks\n
  \ serviceClusterIPRange: 100.64.0.0/13\n  storageBackend: etcd3\nkubeControllerManager:\n
  \ allocateNodeCIDRs: true\n  attachDetachReconcileSyncPeriod: 1m0s\n  cloudProvider:
  aws\n  clusterCIDR: 100.96.0.0/11\n  clusterName: this.is.truly.a.really.really.long.cluster-name.minimal.example.com\n
  \ configureCloudRoutes: false\n  image: registry.k8s.io/kube-controller-manager:v1.21.0\n
  \ leaderElection:\n    leaderElect: true\n  logLevel: 2\n  useServiceAccountCredentials:
  true\nkubeProxy:\n  clusterCIDR: 100.96.0.0/11\n  cpuRequest: 100m\n  image: registry.k8s.io/kube-proxy:v1.21.0\n
  \ logLevel: 2\nkubeScheduler:\n  image: registry.k8s.io/kube-scheduler:v1.21.0\n
  \ leaderElection:\n    leaderElect: true\n  logLevel: 2\nkubelet:\n  cgroupDriver:
  systemd\n  cgroupRoot: /\n  cloudProvider: aws\n  clusterDNS: 100.64.0.10\n  clusterDomain:
  cluster.local\n  enableDebuggingHandlers: true\n  evictionHard: memory.available<100Mi,nodefs.available<10%,nodefs.inodesFree<5%,imagefs.available<10%,imagefs.inodesFree<5%\n
  \ kubeconfigPath: /var/lib/kubelet/kubeconfig\n  logLevel: 2\n  networkPluginName:
  cni\n  podInfraContainerImage: registry.k8s.io/pause:3.6\n  podManifestPath: /etc/kubernetes/manifests\n
  \ shutdownGracePeriod: 30s\n  shutdownGracePeriodCriticalPods: 10s\nmasterKubelet:\n
  \ cgroupDriver: systemd\n  cgroupRoot: /\n  cloudProvider: aws\n  clusterDNS: 100.64.0.10\n
  \ clusterDomain: cluster.local\n  enableDebuggingHandlers: true\n  evictionHard:
  memory.available<100Mi,nodefs.available<10%,nodefs.inodesFree<5%,imagefs.available<10%,imagefs.inodesFree<5%\n
  \ kubeconfigPath: /var/lib/kubelet/kubeconfig\n  logLevel: 2\n  networkPluginName:
  cni\n  podInfraContainerImage: registry.k8s.io/pause:3.6\n  podManifestPath: /etc/kubernetes/manifests\n
  \ registerSchedulable: false\n  shutdownGracePeriod: 30s\n  shutdownGracePeriodCriticalPods:
  10s\n\n__EOF_CLUSTER_SPEC\n\ncat > conf/kube_env.yaml << '__EOF_KUBE_ENV'\nCloudProvider:
  aws\nConfigBase: memfs://clusters.example.com/this.is.truly.a.really.really.long.cluster-name.minimal.example.com\nInstanceGroupName:
  master-us-test-1a\nInstanceGroupRole: Master\nNodeupConfigHash: urLp/r2nq7WqKItlcXIPY4DX+4Au4RmsvS2PF4FJQgw=\n\n__EOF_KUBE_ENV\n\ndownload-release\necho
  \"== nodeup node config done ==\"\n"
? Resources.AWSEC2LaunchTemplatenodesthisistrulyareallyreallylongclusternameminimalexamplecom.Properties.LaunchTemplateData.UserData
: "#!/bin/bash\nset -o errexit\nset -o nounset\nset -o pipefail\n\nNODEUP_URL_AMD64=https://artifacts.k8s.io/binaries/kops/1.21.0-alpha.1/linux/amd64/nodeup,https://github.com/kubernetes/kops/releases/download/v1.21.0-alpha.1/nodeup-linux-amd64\nNODEUP_HASH_AMD64=585fbda0f0a43184656b4bfc0cc5f0c0b85612faf43b8816acca1f99d422c924\nNODEUP_URL_ARM64=https://artifacts.k8s.io/binaries/kops/1.21.0-alpha.1/linux/arm64/nodeup,https://github.com/kubernetes/kops/releases/download/v1.21.0-alpha.1/nodeup-linux-arm64\nNODEUP_HASH_ARM64=7603675379699105a9b9915ff97718ea99b1bbb01a4c184e2f827c8a96e8e865\n\nexport
  AWS_REGION=us-test-1\n\n\n\n\nsysctl -w net.core.rmem_max=16777216 || true\nsysctl
  -w net.core.wmem_max=16777216 || true\nsysctl -w net.ipv4.tcp_rmem='4096 87380 16777216'
  || true\nsysctl -w net.ipv4.tcp_wmem='4096 87380 16777216' || true\n\n\nfunction
  ensure-install-dir() {\n  INSTALL_DIR=\"/opt/kops\"\n  # On ContainerOS, we install
  under /var/lib/toolbox; /opt is ro and noexec\n  if [[ -d /var/lib/toolbox ]]; then\n
  \   INSTALL_DIR=\"/var/lib/toolbox/kops\"\n  fi\n  mkdir -p ${INSTALL_DIR}/bin\n
  \ mkdir -p ${INSTALL_DIR}/conf\n  cd ${INSTALL_DIR}\n}\n\ntry-download-file() {\n
  \ local -r url=\"$1\"\n  local -r file=\"$2\"\n  local -r auth=\"$3\"\n  if [[ \"$auth\"
  == \"\" ]]; then\n        if curl -f --compressed -Lo \"${file}\" --connect-timeout
  20 --retry 6 --retry-delay 10 \"${url}\"; then return 0; fi\n        if wget --compression=auto
  -O \"${file}\" --connect-timeout=20 --tries=6 --wait=10 \"${url}\"; then return
  0; fi\n        if curl -f -Lo \"${file}\" --connect-timeout 20 --retry 6 --retry-delay
  10 \"${url}\"; then return 0; fi\n        if wget -O \"${file}\" --connect-timeout=20
  --tries=6 --wait=10 \"${url}\"; then return 0; fi\n  else\n        if curl -f --compressed
  -Lo \"${file}\" -v -H \"Authorization: Bearer ${auth}\" --connect-timeout 20 --retry
  6 --retry-delay 10 \"${url}\"; then return 0; fi\n        if curl -f -Lo \"${file}\"
  -v -H \"Authorization: Bearer ${auth}\" --connect-timeout 20 --retry 6 --retry-delay
  10 \"${url}\"; then return 0; fi\n  fi\n  return 1\n}\n\n# Retry a download until
  we get it. args: name, sha, urls\ndownload-or-bust() {\n  local -r file=\"$1\"\n
  \ local -r hash=\"$2\"\n  local -r urls=( $(split-commas \"$3\") )\n\n  if [[ -f
  \"${file}\" ]]; then\n    if ! validate-hash \"${file}\" \"${hash}\"; then\n      rm
  -f \"${file}\"\n    else\n      return 0\n    fi\n  fi\n\n  while true; do\n    for
  url in \"${urls[@]}\"; do\n      local access_token=\"\"\n      if [[ \"${GCE_ACCESS_TOKEN_URL:-}\"
  != \"\" ]]; then\n        # The token always begins with 'ya29' and continues until
  the next double-quote.\n        # We would normally use jq to be more tolerant of
  format changes, \n        # but it's not available in flatcar during startup (depends
  on docker, which isn't up yet.)\n        access_token=$(curl \"$GCE_ACCESS_TOKEN_URL\"
  -H \"Metadata-Flavor: Google\" | grep -Eo 'ya29\\.[^\\\"]*')\n      fi\n\n      echo
  \"Attempting download of ${url}\"\n      if ! try-download-file \"${url}\" \"${file}\"
  \"${access_token}\" ; then\n        continue\n      fi\n      if ! validate-hash
  \"${file}\" \"${hash}\"; then\n        echo \"== Hash validation of ${url} failed.
  Retrying. ==\"\n        rm -f \"${file}\"\n      else\n        echo \"== Downloaded
  ${url} (SHA256 = ${hash}) ==\"\n        return\n      fi\n    done\n\n    echo \"Download
  failed with all plausible commands; sleeping before retrying\"\n    sleep 60\n  done\n}\n\nvalidate-hash()
  {\n  local -r file=\"$1\"\n  local -r expected=\"$2\"\n  local actual\n\n  actual=$(sha256sum
  ${file} | awk '{ print $1 }') || true\n  if [[ \"${actual}\" != \"${expected}\"
  ]]; then\n    echo \"== ${file} corrupted, hash ${actual} doesn't match expected
  ${expected} ==\"\n    return 1\n  fi\n}\n\nfunction split-commas() {\n  echo $1
  | tr \",\" \"\\n\"\n}\n\nfunction download-release() {\n  case \"$(uname -m)\" in\n
  \ x86_64*|i?86_64*|amd64*)\n    NODEUP_URL=\"${NODEUP_URL_AMD64}\"\n    NODEUP_HASH=\"${NODEUP_HASH_AMD64}\"\n
  \   ;;\n  aarch64*|arm64*)\n    NODEUP_URL=\"${NODEUP_URL_ARM64}\"\n    NODEUP_HASH=\"${NODEUP_HASH_ARM64}\"\n
  \   ;;\n  *)\n    echo \"Unsupported host arch: $(uname -m)\" >&2\n    exit 1\n
  \   ;;\n  esac\n\n  cd ${INSTALL_DIR}/bin\n  download-or-bust nodeup \"${NODEUP_HASH}\"
  \"${NODEUP_URL}\"\n\n  chmod +x nodeup\n\n  echo \"Running nodeup\"\n  # We can't
  run in the foreground because of https://github.com/docker/docker/issues/23793\n
  \ ( cd ${INSTALL_DIR}/bin; ./nodeup --install-systemd-unit --conf=${INSTALL_DIR}/conf/kube_env.yaml
  --v=8  )\n}\n\n####################################################################################\n\n/bin/systemd-machine-id-setup
  || echo \"failed to set up ensure machine-id configured\"\n\necho \"== nodeup node
  config starting ==\"\nensure-install-dir\n\ncat > conf/cluster_spec.yaml << '__EOF_CLUSTER_SPEC'\ncloudConfig:\n
  \ awsEBSCSIDriver:\n    enabled: false\n  manageStorageClasses: true\ncontainerRuntime:
  containerd\ncontainerd:\n  logLevel: info\n  version: 1.4.12\ndocker:\n  skipInstall:
  true\nkubeProxy:\n  clusterCIDR: 100.96.0.0/11\n  cpuRequest: 100m\n  image: registry.k8s.io/kube-proxy:v1.21.0\n
  \ logLevel: 2\nkubelet:\n  cgroupDriver: systemd\n  cgroupRoot: /\n  cloudProvider:
  aws\n  clusterDNS: 100.64.0.10\n  clusterDomain: cluster.local\n  enableDebuggingHandlers:
  true\n  evictionHard: memory.available<100Mi,nodefs.available<10%,nodefs.inodesFree<5%,imagefs.available<10%,imagefs.inodesFree<5%\n
  \ kubeconfigPath: /var/lib/kubelet/kubeconfig\n  logLevel: 2\n  networkPluginName:
  cni\n  podInfraContainerImage: registry.k8s.io/pause:3.6\n  podManifestPath: /etc/kubernetes/manifests\n
  \ shutdownGracePeriod: 30s\n  shutdownGracePeriodCriticalPods: 10s\n\n__EOF_CLUSTER_SPEC\n\ncat
  > conf/kube_env.yaml << '__EOF_KUBE_ENV'\nCloudProvider: aws\nConfigBase: memfs://clusters.example.com/this.is.truly.a.really.really.long.cluster-name.minimal.example.com\nInstanceGroupName:
  nodes\nInstanceGroupRole: Node\nNodeupConfigHash: yfDv+pqge28jGHwqpMqOc1aATLoceUPU+ktGCJQrU4s=\n\n__EOF_KUBE_ENV\n\ndownload-release\necho
  \"== nodeup node config done ==\"\n"
